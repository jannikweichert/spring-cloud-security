= Spring Cloud Security
:github-base: https://github.com/spring-cloud
:security-base: https://github.com/spring-cloud/spring-cloud-security

include::intro.adoc[]

== Quickstart

include::quickstart.adoc[]

== More Detail

=== Single Sign On

An app will activate `@EnableOAuth2Sso` if you bind provide the
following properties in the `Environment`:

* `oauth2.client.\*` with `*` equal to `clientId`, `clientSecret`,
  `tokenUri` and `authorizationUri` and;

* `oauth2.resource.preferTokenInfo=false` and
  `oauth2.resource.userInfoUri` to use the "/me" resource
  (e.g. "https://uaa.run.pivotal.io/userinfo" on PWS), or

* `oauth2.resource.tokenInfoUri` to use the token decoding endpoint
  (e.g. "https://uaa.run.pivotal.io/check_token" on PWS), or

* `oauth2.resource.jwt.keyValue` or `oauth2.resource.jwt.keyUri` to
  decode a JWT token locally, where the key is a verification key. The
  verification key value is either a symmetric secret or PEM-encoded
  RSA public key. If you don't have the key and it's public you can
  provide a URI where it can be downloaded (as a JSON object with a
  "value" field). E.g. on PWS:
  + 
----
$ curl https://uaa.run.pivotal.io/token_key
{"alg":"SHA256withRSA","value":"-----BEGIN PUBLIC KEY-----\nMIIBI...\n-----END PUBLIC KEY-----\n"}
----

=== Resource Server

The `@EnableOAuth2Resource` annotation will protect your API endpoints
if you have the same environment settings as the SSO client, except
that it doesn't need a `tokenUri` or `authorizationUri`, and it also
doesn't need a `clientId` and `clientSecret` if it isn't using the
`tokenInfoUri` (i.e. if it has `jwt.*` or `userInfoUri`).

=== Token Relay

If your app has a
http://cloud.spring.io/spring-cloud.html#netflix-zuul-reverse-proxy[Spring
Cloud Zuul] embedded reverse proxy (using `@EnableZuulProxy`) then you
can ask it to forward OAuth2 access tokens downstream to the services
it is proxying. Thus the SSO app above can be enhanced simply like this:

.app.groovy
[source,java]
----
@Controller
@EnableOAuth2Sso
@EnableZuulProxy
class Application {
  
  @RequestMapping('/'
  String home() {
    'Hello World'
  }

}
----

and it will (in addition to loggin the user in and grabbing a token)
pass the authentication token downstream to the `/proxy/*`
services. If those services are implemented with
`@EnableOAuth2Resource` then they will get a valid token in the
correct header.

How does it work? The `@EnableOAuth2Sso` annotation pulls in
`spring-cloud-starter-security` (which you could do manually in a
traditional app), and that has some autoconfiguration for a
`ZuulFilter`, which itself is activated because Zuul is on the
classpath (via `@EnableZuulProxy`). The
{security-base}/tree/master/src/main/java/org/springframework/cloud/security/proxy/OAuth2TokenRelayFilter.java[filter]
just extracts an access token from the currently authenticated user,
and puts it in a request header for the downstream requests.

